# 面向对象程序设计
## OOP：概述
面向对象程序设计的核心思想是数据抽象，继承和动态绑定。
### 继承
通过继承联系在一起的类构成一种**层次关系**。在层次关系的根部有一个**基类**，其他类则直接或者间接地从基类继承而来，这些继承得到的类称为**派生类**。  
基类将**类型相关的函数**（派生类中有特殊定义）与派生类不做改变直接继承的函数区别对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。  
```cpp
calss Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```
派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个**冒号**，后面紧跟以**逗号分隔的基类列表**，其中每个基类前面可以有**访问说明符**：
```cpp
class Bulk_quote : public Quote {
public:
    double net_price(size_t) const override;
}
```
第一行的public就是访问说明符。  
派生类必须在其内部对所有重新定义的虚函数进行声明（不重新定义就无需声明）。  派生类可以在这样的函数之前加上**virtual**关键字，但不是必须的。  
派生类可以通过在函数的形参列表之后增加一个**override**关键字来显式地注明使用它来改写基类的虚函数。  
### 动态绑定
通过使用动态绑定，我们能用同一段代码分别处理Quote和Bulk_quote的对象。  
```cpp
//计算并打印销售给定数量的某种书籍所得的费用
double print_total(ostream &os,const Quote &item,size_t n) {
    //根据传入item形参的对象类型调用Quote::net_price
    //或者Bulk_quote::net_price
    double ret = item.net_price(n);
    os<<"ISBN: "<<item.isbn()
      <<" # sold: "<<n<<" total due: "<<ret<<endl;
    return ret;
}
```
关于上面的函数有两个有意思的结论：① 因为函数print_total的**item形参是基类Quote的一个引用**，所以我们**既能使用基类Quote对象，也能使用派生类Bulk_quote的对象调用它**；② 又因为print_total是使用**引用类型调用net_price函数**的，所以**实际传入print_total的对象类型将决定到底执行net_price的哪个版本**：
```cpp
//basic的类型是Quote；bulk的类型是Bulk_quote
print_total(cout,basic,20);  //调用Quote的net_price
print_total(cout,bulk,20);  //调用Bulk_quote的net_price
```
在上述过程中函数的运行版本由实参决定，即在**运行时选择函数的版本**，所以**动态绑定又被称为运行时绑定**。  
当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 定义基类和派生类
### 定义基类
```cpp
class Quote {
public:
	Quote() = default;
	Quote(const string &book, double sales_price) :bookNo(book), price(sales_price) {}
	string isbn() { return bookNo; }
	virtual double net_price(size_t n) const { return n * price; }
	virtual ~Quote() = default;
private:
	string bookNo;
protected:
	double price = 0.0;
};
```
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。  
#### 成员函数与继承
只有声明为虚函数的成员函数才会执行动态绑定。  
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。  
#### 访问控制与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。**派生类能访问共有成员，而不能访问私有成员。**不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。**我们用受保护的（protected）访问运算符说明这样的成员。**

### 定义派生类
派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个**冒号**，后面紧跟以**逗号分隔的基类列表**，其中每个基类前面可以有**访问说明符**：public、protected、private三种之一。
派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明（不是所有虚函数都需要重新声明，而是需要覆盖的）。
```cpp
class Bulk_quote :public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string&，double, size_t, double);
	//覆盖基类的函数版本以实现基于大量购买的折扣政策
	double net_price(size_t n) const { return n * price*0.95; }
private:
	size_t min_qty = 0;  //适用折扣政策的最低购买量
	double discount = 0.0;  //以小数表示的折扣额
};
```
#### 派生类中的虚函数
如果派生类**没有覆盖**其基类中的某个虚函数，则该函数的行为类似于其他的普通成员，派生类会**直接继承其在基类中的版本**。
派生类可以在它覆盖的函数前使用**virtual关键字**，但不是必须。  
派生类也可以显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符都免添加一个**关键字override**。  
#### 派生类对象及派生类向基类的类型转换
因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。  
```cpp
Quote item;  //基类对象
Bulk_quote bulk;  //派生类对象
Quote *p = &item;  //p指向Quote对象
p = &bulk;  //p指向bulk的基类部分
Quote &r = bulk;  //r绑定到bulk的基类部分
```
这种转换通常称为**派生类到基类的类型转换**。由编译器隐式地执行。  
这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。  
**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。**  
#### 派生类构造函数
尽管在派生类对象中含有从基类继承而来的成员，但是**派生类并不能直接初始化这些成员**。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。  
**每个类控制它自己的成员初始化过程。**
```cpp
//接受四个参数的Bulk_quote构造函数：
Bulk_quote(const string &book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc){}
```
其中调用了Quote的构造函数来初始化基类的成员。   
除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。  
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。  
#### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员。  
#### 继承与静态成员
如果基类定义了一个**静态成员**，则在**整个继承体系中只存在该成员的唯一定义**。  
静态成员遵循通用的访问控制规则，派生类无权访问积累中private的静态成员。  
#### 派生类的声明
派生类的声明与其他类没有区别。  
```cpp
class Bulk_quote : public Quote;  //错误：派生列表不应该出现在此处
class Bulk_quote;  //正确
```
#### 被用作基类的类 
如果我们想将某个类用作**基类**，则该类**必须已经定义而非仅仅声明**。           
一个类是基类的同时它也可以是一个派生类：
```cpp
class Base {/*...*/};
class D1:public Base {/*...*/};
class D2:public D1 {/*...*/};
```
以上继承体系中Base是D1的**直接基类**，同时也是D2的**间接基类**。
#### 防止继承的发生
在类名之后跟一个关键字**final**：
```cpp
class NODerived final {/*...*/};
class Base {/*...*/};
class Last final:Base {/*...*/};
class Bad:NoDerived {/*...*/};  //错误：NODerived是final的
class Bad2:Last {/*...*/};  //错误：Last是final的
```

### 类型转换与继承
我们**可以将基类的指针或引用绑定到派生类对象上**。也就是说：当使用基类的引用或指针时，实际上我们并不清楚该引用或指针绑定对象的真实类型。  
和内置指针一样**智能指针类也支持派生类向基类的类型转换**。
#### 静态类型与动态类型
当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。  
如果表达时既不是引用也不是指针，则它的动态类型永远与静态类型一致。  
**基类的指针或引用的静态类型可能与其动态类型不一致。**
#### 不存在从基类向派生类的隐式类型转换
但是显式地类型转换是可以的。  
编译器在编译时无法确定某个特定的转换在运行时是否安全。这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。**如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换**，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强制覆盖掉编译器的检查工作。  
#### 基类和派生类对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效。  
很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。  
基类的拷贝/移动操作成员函数接受引用作为参数，所以我们可以传递一个派生类的对象。但这个过程中会忽略派生类独有的部分，也就是说派生类的自有部分被**切掉了**。  
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略。
#### ★存在继承关系的类型之间的转换规则
●从派生类向基类的类型转换只对指针或引用类型有效  
●基类向派生类不存在隐式类型转换  
●和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。  

## 虚函数
### ★C++的多态性
OOP的核心思想是多态性。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。  
当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用对象是什么类型。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。  
当且仅当对**通过指针或引用（形参）调用虚函数**时，才会在**运行时解析**该调用，也只有在这种情况下对象的动态类型才可能与静态类型不同。
### 派生类中的虚函数
基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。  
同样，派生类中的虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时。也就是说，如果B由A派生得到，则基类A中返回A\*或A&的虚函数在B中的对应函数可以返回B\*或B&。这也要求B到A的类型转换是可访问的。  
### virtual、override、final
派生类可以在它覆盖的函数前使用**virtual关键字**，但不是必须。  
派生类也可以显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符都免添加一个**关键字override**。    
在类名之后跟一个关键字**final**可以防止继承的发生：
```cpp
class NODerived final {/*...*/};
class Base {/*...*/};
class Last final:Base {/*...*/};
class Bad:NoDerived {/*...*/};  //错误：NODerived是final的
class Bad2:Last {/*...*/};  //错误：Last是final的
```
### 虚函数与默认实参
和其他函数一样，虚函数也可以拥有默认实参（拥有默认初始值）。如果某次函数调用使用了默认实参，则**该实参值由本次调用的静态类型决定**。  
换句话说，如果我们**通过基类的引用或指针调用函数，则使用基类中定义的默认实参**，即使实际运行的是派生类中的函数版本也是如此。
如果基类和派生类中虚函数的默认实参定义不同，很可能产生意想不到的结果！（使用基类指针引用做形参的函数，其默认实参只可能是基类定义的默认实参，派生类的默认实参并不会采用）  
### 回避虚函数的机制
在的某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。
```cpp
double undiscounted = baseP->Quote::net_price(42);
```
改代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型是什么。

## 抽象基类
### 纯虚函数
我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数，从而令程序实现我们的设计意图。
### 含有纯虚函数的类是抽象基类
抽象基类负责定义接口，而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象。**
## 访问控制与继承
### 受保护的成员
一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。  
派生类的成员或友元**只能通过派生类对象来访问基类的受保护成员**。   
### 公有、私有和受保护继承
在基类的访问属性 | 继承方式 | 在派生类中的访问属性 
:-: | :-: | :-: 
private | public | 不可访问 
private | private | 不可访问 
private | protected | 不可访问 
public | public | public 
public | private | private 
public | protected | pretected 
protected | public | protected 
protected | private | private 
protected | protected | protected 
### 派生类向基类转换的可访问性
假定D继承自B：
●只有当D公有地继承B时，用户代码才能使用派生类向基类的转换。  
●不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。  
●如果D继承B的方式是公有或者有保护                                                                                               的，则D的派生类的成员和友元可以试用D向B的类型转换，反之不能。  
### 友元与继承
就像友元关系不能传递一样，友元关系也不能继承。
### 改变个别成员的可访问性
```cpp
class Base{
public:
    size_t size() const { return n; }
private:
    size_t n;
};
class Derived : private Base {
public:
    using Base::size;
protected:
    using Base::n;
};
```
Derived使用using将private继承的成员size和n访问性改变了。  
派生类只能为那些他可以访问的名字提供using声明。  
### 默认的继承保护级别
struct的默认成员访问说明符为public，其默认派生访问说明符为public。  
class的默认成员访问说明符为private，其默认派生访问说明符为private。  
除此之外二者再无区别。