# 用于大型程序的工具
## 异常处理
### 抛出异常
在C++中，我们通过**抛出**一条表达式来引发一个异常。被抛出的表达式的类型以及当前调用链共同决定了哪段处理代码将被用来处理该异常。  
当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到与之匹配的catch模块。  
控制权从一处转移到另一处，这有两个重要含义：  
①沿着调用链的函数可能会提早退出  
②一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁  
因为跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似于return语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。  
#### 栈展开
当**throw**出现在一个**try语句块**内时，检查与**该try块关联的catch语句**。若在这一步没有找到匹配的catch则一层层向外寻找，直至最终还是找不到，程序将调用标准库函数terminate，**terminate负责终止程序的执行过程**。  如上过程称为 栈展开。
#### 栈展开过程中对象被自动销毁
栈展开过程中，沿着调用链的函数可能会提早退出。如果栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。①类类型对象的析构函数将被自动调用。②销毁内置类型的对象时不需要做任何事情。  
即使某个对象只构造了一部分，我们也要确保已构造的成员能够正确的销毁。  
#### 析构函数与异常
析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过。  
类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确的释放。  
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出异常，并且析构函数自身没能捕获到该异常，则程序将被终止。  
#### 异常对象
异常对象是一种特殊对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw语句中的表达式必须拥有完全类型。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。  
当我们抛出一条表达式时，该表达式的**静态编译时类型**决定了异常对象的类型。很多情况下程序抛出的表达式类型来自某个继承体系。如果一条throw表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（只有基类部分被抛出）。  
抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。

### 捕获异常
catch子句中的**异常声明**看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果catch无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。   
声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。  
当进入一个catch语句之后，通过异常对象初始化异常声明中的参数。  
如果catch的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。  rugocatch的参数是非引用，则该参数将以常规方式绑定到异常对象上。  
异常声明的静态类型将决定catch语句所能执行的操作。如果catch的参数是基类类型，则catch无法使用派生类特有的任何成员。  
通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义成引用类型。  
#### 查找匹配的处理代码
在搜寻catch语句的过程中，我们找出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。  
当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前。  
异常的类型和catch声明的类型通常要求是精确匹配的，除了以下情况：
①允许从非常量向常量的类型转换  
②允许从派生类向基类的类型转换  
③数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针  
#### 重新抛出
有时，一个单独的catch语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。这就是重新抛出，仍然是一条throw语句但不包括任何表达式：`throw;`
#### 捕获所有异常的处理代码  
形如`catch(...)`。

### 函数try语句块与构造函数
要想处理构造函数初始值抛出的异常，我们必须将构造函数写成**函数try语句块**的形式。  
```cpp
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
    data(std::make_shared<std::vector<T>>(il)){
    }catch(const std::bad_alloc &e){ hand_out_of_memory(e); }
```
注意：关键字try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前。与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。  
但是，初始化构造函数的参数时也可能发生异常，这样的异常不属于函数try语句块的一部分。该异常属于调用表达式的一部分，将在调用者所在的上下文中处理。

### noexcept 异常说明
**noexcept说明符** 指定某个函数不会抛出异常。  
对于一个函数来说，noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。  
#### 违反异常说明
尽管函数声明了它不会抛出异常，但实际上还是抛出了异常。一旦一个noexcept函数抛出了异常，程序就会调用terminate来终止程序。  
因此，noexcept可以用在两种情况：①确认不会抛出异常  ②根本不知道如何处理异常  
```cpp
void recoup(int) noexcept;  //recoup不会抛出异常
void recoup(int) throw();  //等价的声明
```
#### 异常说明的实参
```cpp
void recoup(int) noexcept(true);  //recoup不会抛出异常
void alloc(int) noexcept(false);  //alloc可能抛出异常
```
#### noexcept运算符  
注意：**noexcept说明符和noexcept运算符是noexcept的两重含义**，注意区分！  
noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式。  
```cpp
noexcept(e)
```
当e调用的所有函数都做了不抛出说明且e本身不含有throw语句时，上述表达式为true；否则noexcept(e)返回false。  
```cpp
void f() noexcept(noexcept(g()));  //f和g的异常说明一致  
```
#### 异常说明与指针、虚函数和拷贝控制
**函数指针**及该指针所指的函数必须具有一致的异常说明。  
如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，我们显式或隐式地说明了指针可能会抛出异常，则该指针既可以指向任何异常说明的函数。  
在**继承体系**中也有类似的限制，如果基类的虚函数不允许异常抛出，则后续的派生虚函数也必须有相同的异常说明。反之，没有限制。  
当编译器**合成拷贝控制成员**时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是noexcept的。否则合成的成员是noexcept(false)的。  
如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与合成拷贝控制成员时一样。