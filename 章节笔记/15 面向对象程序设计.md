# 面向对象程序设计
## OOP：概述
面向对象程序设计的核心思想是数据抽象，继承和动态绑定。
### 继承
通过继承联系在一起的类构成一种**层次关系**。在层次关系的根部有一个**基类**，其他类则直接或者间接地从基类继承而来，这些继承得到的类称为**派生类**。  
基类将**类型相关的函数**（派生类中有特殊定义）与派生类不做改变直接继承的函数区别对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。  
```cpp
calss Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```
派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个**冒号**，后面紧跟以**逗号分隔的基类列表**，其中每个基类前面可以有**访问说明符**：
```cpp
class Bulk_quote : public Quote {
public:
    double net_price(size_t) const override;
}
```
第一行的public就是访问说明符。  
派生类必须在其内部对所有重新定义的虚函数进行声明（不重新定义就无需声明）。  派生类可以在这样的函数之前加上**virtual**关键字，但不是必须的。  
派生类可以通过在函数的形参列表之后增加一个**override**关键字来显式地注明使用它来改写基类的虚函数。  
### 动态绑定
通过使用动态绑定，我们能用同一段代码分别处理Quote和Bulk_quote的对象。  
```cpp
//计算并打印销售给定数量的某种书籍所得的费用
double print_total(ostream &os,const Quote &item,size_t n) {
    //根据传入item形参的对象类型调用Quote::net_price
    //或者Bulk_quote::net_price
    double ret = item.net_price(n);
    os<<"ISBN: "<<item.isbn()
      <<" # sold: "<<n<<" total due: "<<ret<<endl;
    return ret;
}
```
关于上面的函数有两个有意思的结论：① 因为函数print_total的**item形参是基类Quote的一个引用**，所以我们**既能使用基类Quote对象，也能使用派生类Bulk_quote的对象调用它**；② 又因为print_total是使用**引用类型调用net_price函数**的，所以**实际传入print_total的对象类型将决定到底执行net_price的哪个版本**：
```cpp
//basic的类型是Quote；bulk的类型是Bulk_quote
print_total(cout,basic,20);  //调用Quote的net_price
print_total(cout,bulk,20);  //调用Bulk_quote的net_price
```
在上述过程中函数的运行版本由实参决定，即在**运行时选择函数的版本**，所以**动态绑定又被称为运行时绑定**。  
当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 定义基类和派生类
### 定义基类
```cpp
class Quote {
public:
	Quote() = default;
	Quote(const string &book, double sales_price) :bookNo(book), price(sales_price) {}
	string isbn() { return bookNo; }
	virtual double net_price(size_t n) const { return n * price; }
	virtual ~Quote() = default;
private:
	string bookNo;
protected:
	double price = 0.0;
};
```
基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。  
#### 成员函数与继承
只有声明为虚函数的成员函数才会执行动态绑定。  
成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。  
#### 访问控制与继承
派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。**派生类能访问共有成员，而不能访问私有成员。**不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。**我们用受保护的（protected）访问运算符说明这样的成员。**

### 定义派生类
派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先一个**冒号**，后面紧跟以**逗号分隔的基类列表**，其中每个基类前面可以有**访问说明符**：public、protected、private三种之一。
派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明（不是所有虚函数都需要重新声明，而是需要覆盖的）。
```cpp
class Bulk_quote :public Quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string&，double, size_t, double);
	//覆盖基类的函数版本以实现基于大量购买的折扣政策
	double net_price(size_t n) const { return n * price*0.95; }
private:
	size_t min_qty = 0;  //适用折扣政策的最低购买量
	double discount = 0.0;  //以小数表示的折扣额
};
```
#### 派生类中的虚函数
如果派生类**没有覆盖**其基类中的某个虚函数，则该函数的行为类似于其他的普通成员，派生类会**直接继承其在基类中的版本**。
派生类可以在它覆盖的函数前使用**virtual关键字**，但不是必须。  
派生类也可以显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符都免添加一个**关键字override**。  
#### 派生类对象及派生类向基类的类型转换
因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。  
```cpp
Quote item;  //基类对象
Bulk_quote bulk;  //派生类对象
Quote *p = &item;  //p指向Quote对象
p = &bulk;  //p指向bulk的基类部分
Quote &r = bulk;  //r绑定到bulk的基类部分
```
这种转换通常称为**派生类到基类的类型转换**。由编译器隐式地执行。  
这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。  
**在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。**  
#### 派生类构造函数
尽管在派生类对象中含有从基类继承而来的成员，但是**派生类并不能直接初始化这些成员**。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。  
**每个类控制它自己的成员初始化过程。**
```cpp
//接受四个参数的Bulk_quote构造函数：
Bulk_quote(const string &book,double p,size_t qty,double disc):Quote(book,p),min_qty(qty),discount(disc){}
```
其中调用了Quote的构造函数来初始化基类的成员。   
除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。  
首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。  
#### 派生类使用基类的成员
派生类可以访问基类的公有成员和受保护成员。  
#### 继承与静态成员
如果基类定义了一个**静态成员**，则在**整个继承体系中只存在该成员的唯一定义**。  
静态成员遵循通用的访问控制规则，派生类无权访问积累中private的静态成员。  
#### 派生类的声明
派生类的声明与其他类没有区别。  
```cpp
class Bulk_quote : public Quote;  //错误：派生列表不应该出现在此处
class Bulk_quote;  //正确
```
#### 被用作基类的类 
如果我们想将某个类用作**基类**，则该类**必须已经定义而非仅仅声明**。           
一个类是基类的同时它也可以是一个派生类：
```cpp
class Base {/*...*/};
class D1:public Base {/*...*/};
class D2:public D1 {/*...*/};
```
以上继承体系中Base是D1的**直接基类**，同时也是D2的**间接基类**。
#### 防止继承的发生
在类名之后跟一个关键字**final**：
```cpp
class NODerived final {/*...*/};
class Base {/*...*/};
class Last final:Base {/*...*/};
class Bad:NoDerived {/*...*/};  //错误：NODerived是final的
class Bad2:Last {/*...*/};  //错误：Last是final的
```

### 类型转换与继承
我们**可以将基类的指针或引用绑定到派生类对象上**。也就是说：当使用基类的引用或指针时，实际上我们并不清楚该引用或指针绑定对象的真实类型。  
和内置指针一样**智能指针类也支持派生类向基类的类型转换**。
#### 静态类型与动态类型
当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。  
如果表达时既不是引用也不是指针，则它的动态类型永远与静态类型一致。  
**基类的指针或引用的静态类型可能与其动态类型不一致。**
#### 不存在从基类向派生类的隐式类型转换
但是显式地类型转换是可以的。  
编译器在编译时无法确定某个特定的转换在运行时是否安全。这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。**如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换**，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强制覆盖掉编译器的检查工作。  
#### 基类和派生类对象之间不存在类型转换
派生类向基类的自动类型转换只对指针或引用类型有效。  
很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。  
基类的拷贝/移动操作成员函数接受引用作为参数，所以我们可以传递一个派生类的对象。但这个过程中会忽略派生类独有的部分，也就是说派生类的自有部分被**切掉了**。  
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略。
#### ★存在继承关系的类型之间的转换规则
●从派生类向基类的类型转换只对指针或引用类型有效  
●基类向派生类不存在隐式类型转换  
●和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。  

## 虚函数
### ★C++的多态性
OOP的核心思想是多态性。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。  
当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正的作用对象是什么类型。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。  
当且仅当对**通过指针或引用（形参）调用虚函数**时，才会在**运行时解析**该调用，也只有在这种情况下对象的动态类型才可能与静态类型不同。
### 派生类中的虚函数
基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。  
同样，派生类中的虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时。也就是说，如果B由A派生得到，则基类A中返回A\*或A&的虚函数在B中的对应函数可以返回B\*或B&。这也要求B到A的类型转换是可访问的。  
### virtual、override、final
派生类可以在它覆盖的函数前使用**virtual关键字**，但不是必须。  
派生类也可以显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符都免添加一个**关键字override**。    
在类名之后跟一个关键字**final**可以防止继承的发生：
```cpp
class NODerived final {/*...*/};
class Base {/*...*/};
class Last final:Base {/*...*/};
class Bad:NoDerived {/*...*/};  //错误：NODerived是final的
class Bad2:Last {/*...*/};  //错误：Last是final的
```
### 虚函数与默认实参
和其他函数一样，虚函数也可以拥有默认实参（拥有默认初始值）。如果某次函数调用使用了默认实参，则**该实参值由本次调用的静态类型决定**。  
换句话说，如果我们**通过基类的引用或指针调用函数，则使用基类中定义的默认实参**，即使实际运行的是派生类中的函数版本也是如此。
如果基类和派生类中虚函数的默认实参定义不同，很可能产生意想不到的结果！（使用基类指针引用做形参的函数，其默认实参只可能是基类定义的默认实参，派生类的默认实参并不会采用）  
### 回避虚函数的机制
在的某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。
```cpp
double undiscounted = baseP->Quote::net_price(42);
```
改代码强行调用Quote的net_price函数，而不管baseP实际指向的对象类型是什么。

## 抽象基类
### 纯虚函数
我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数，从而令程序实现我们的设计意图。
### 含有纯虚函数的类是抽象基类
抽象基类负责定义接口，而后续的其他类可以覆盖该接口。**我们不能（直接）创建一个抽象基类的对象。**
## 访问控制与继承
### 受保护的成员
一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。  
派生类的成员或友元**只能通过派生类对象来访问基类的受保护成员**。   
### 公有、私有和受保护继承
在基类的访问属性 | 继承方式 | 在派生类中的访问属性 
:-: | :-: | :-: 
private | public | 不可访问 
private | private | 不可访问 
private | protected | 不可访问 
public | public | public 
public | private | private 
public | protected | pretected 
protected | public | protected 
protected | private | private 
protected | protected | protected 
### 派生类向基类转换的可访问性
假定D继承自B：
●只有当D公有地继承B时，用户代码才能使用派生类向基类的转换。  
●不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换。  
●如果D继承B的方式是公有或者有保护的，则D的派生类的成员和友元可以试用D向B的类型转换，反之不能。  
### 友元与继承
就像友元关系不能传递一样，友元关系也不能继承。
### 改变个别成员的可访问性
```cpp
class Base{
public:
    size_t size() const { return n; }
private:
    size_t n;
};
class Derived : private Base {
public:
    using Base::size;
protected:
    using Base::n;
};
```
Derived使用using将private继承的成员size和n访问性改变了。  
派生类只能为那些他可以访问的名字提供using声明。  
### 默认的继承保护级别
struct的默认成员访问说明符为public，其默认派生访问说明符为public。  
class的默认成员访问说明符为private，其默认派生访问说明符为private。  
除此之外二者再无区别。

## 继承中的类作用域
当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正常解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。  
### 名字冲突与继承
派生类的成员将隐藏同名的基类成员。  
### 通过作用域运算符来使用隐藏的成员
```cpp
struct Derived : Base {
    int get_base_mem(){return Base::mem;}
};
```
### 一如往常，名字查找先于类型检查
生命在内层作用域的函数并**不会重载**声明在外层作用域的函数。  
如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然**会被隐藏**。
### 虚函数与作用域
**基类与派生类中的虚函数必须有相同的形参列表**。加入基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。  
```cpp
class Base {
public:
	virtual int fcn();
};
class D1 : public Base {
	int fcn(int); //非虚函数，但是在D1作用域内隐藏fcn虚函数
	virtual void f2();
};
class D2 : public D1 {
public:
	int fcn(int);//非虚函数，隐藏了D1::fcn(int)
	int fcn();//虚函数覆盖了Base::fcn()
	void f2();//虚函数覆盖了D1::f2()
};
```
### 通过基类调用隐藏的虚函数
```cpp
Base bobj; D1 d1obj; D2 d2obj;
Base *bp1 = &bobj,*bp2 = &d1obj, *bp3 = &d2obj;
bp1->fcn();  //虚调用Base::fcn
bp2->fcn();  //虚调用Base::fcn(虽然在D1作用域内fcn()被隐藏但是通过Base的指针可以调用)
bp3->fcn();  //虚调用Base::fcn

D1 *d1p = &d1obj; D2 *d2p = &d2obj;
bp2->f2();  //错误：Base没有名为f2的成员（基类指针只指向派生类的基类部分）
d1p->f2();  //虚调用D1::f2()
d2p->f2();  //虚调用D2::f2()

Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj;
p1->fcn(42);  //错误Base中没有fcn(int)
p2->fcn(42);  //静态绑定D1::fcn(int)
p3->fcn(42);  //静态绑定D2::fcn(int)
```

通过基类的指针或引用可以调用派生类中被隐藏的虚函数。  
非虚函数不会发生动态绑定，实际调用的函数版本由指针的静态类型决定。  
### 覆盖重载的函数
成员函数无论是否是虚函数都能被重载。如果派生类希望所有的重载版本对于它都是可见的，那么他就需要覆盖所有的版本，或者一个也不覆盖。  
最好的解决方案就是使用using声明如`using Base::size;`。  
using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域内。

## 构造函数与拷贝控制
### 虚析构函数
继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。  
只要基类的析构函数是虚析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本：
```cpp
Quote *itemP = new Quote;  //静态类型与动态类型一致
delete itemP;  //调用Quote的析构函数
itemP = new Bulk_quote;  //静态类型与动态类型不一致
delete itemP;  //调用Bulk_quote的析构函数
```
**如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义行为。**

#### 虚析构函数将阻止合成移动操作
基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。因此当我们移动Quote对象时实际使用的是合成的拷贝操作。Quote没有移动操作意味着它的派生类也没有。

### 合成拷贝控制与继承
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类型类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。  
 
 #### 派生类中删除的拷贝控制与基类的关系
 就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：
 &emsp;●如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的。  
 &emsp;●如果基类中有一个不可访问或删除调的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。  
 &emsp;●编译器不会合成一个删除的移动操作。当我们使用default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的。  
 #### 移动操作与继承
 如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。  
 基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。  
 Quote必须显式地定义这些成员。必须同时显式地定义拷贝操作：
```cpp
public:
Quote() = default;
Quote(const Quote&) = default;  
Quote(Quote&&) = default;
```

### 派生类的拷贝控制成员
派生类构造函数在其初始化阶段中**不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分**。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，**也要拷贝和移动基类部分的成员**。类似的，派生类赋值运算符**也必须为其基类部分的成员赋值**。   
和构造函数级赋值运算符不同的是：**析构函数只负责销毁派生类自己分配的资源**。  
#### 定义派生类的拷贝或移动构造函数
当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分：
```cpp
class Base { /*...*/ };
class D:public Base {
public:
    D(const D& d):Base(d){ /*...*/ }
    D(D&& d):Base(move(d)){ /*...*/ }
};
```
基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝或移动构造函数。
#### 派生类赋值运算符
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：
```cpp
//Base::operator=(const Base&)不会被自动调用
D &D::operator=(const D &rhs){
    Base::operator=(rhs);
    //依次为派生类的成员赋值
    return *this;
}
```
#### 派生类析构函数
在析构函数体执行完成后，对象的成员会被隐式销毁，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：
```cpp
class D: public Base {
public:
    //Base::~Base被自动的调用
    ~D(){ /*...*/ }
};
```
对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。  
#### 在构造函数和析构函数中调用虚函数
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

### 继承的构造函数
派生类继承基类构造函数的方式是提供一条注明了直接基类名的using声明语句。  
```cpp
class Bulk_quote:public Disc_quote{
public:
    using Disc_quote::Disc_quote;  //继承Disc_quote的构造函数
    double net_price(size_t) const;
};
```
在Bulk_quote类中，继承的构造函数等价于：
```cpp
Bulk_quote(const string& book,double price,size_t qty,double disc):Disc_quote(book,price,qty,disc){}
```
如果派生类含有自己的数据成员，则这些成员将被默认初始化。  
#### 继承的构造函数的特点
和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的和公有的也是同样的规则。  
一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit或constexpr，则继承的构造函数也拥有相同的属性。   
当一个基类的构造函数含有默认实参时，这些实参并不会被直接继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。  
如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。第一个例外：派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。  第二个例外：默认、拷贝和移动构造函数不会被继承。

## 容器与继承
当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。  
vector<Bulk_quote>中无法存储Quote对象，因为我们不能将Quote对象转换为Bulk_quote对象。  
vector<Quote>中存储Bulk_quote对象，那么Bulk_quote对象的派生类部分会被忽略掉（“切掉”）。
### 在容器中放置（智能）指针而非对象
当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（最好是智能指针）。和通常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。  
```cpp
    vector<shared_ptr<Quote>> vsq;
    int sum_vsq=0;
    vsq.push_back(make_shared<Bulk_quote>("aaa", 2.0, 5, 0.5));
    vsq.push_back(make_shared<Bulk_quote>("bbb", 6.0, 20, 0.5));
    for (auto i : vsq) {
        sum_vsq += i->net_price(10);
    }
    cout << sum_vsq << endl;
```
