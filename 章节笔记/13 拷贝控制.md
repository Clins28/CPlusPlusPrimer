# 拷贝控制
一个类的拷贝控制操作通过5种特殊的成员函数来实现：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）、析构函数（destructor）。
## 拷贝、赋值与销毁
### 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。  
```
class Foo{
public:    
    Foo();//默认构造函数
    Foo(const Foo&);//拷贝构造函数
}
```
拷贝构造函数的第一个参数必须是一个引用类型。

### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。一般情况，合成的拷贝构造函数会将其参数对象的每个非static成员逐个拷贝到正在创建的对象中。  
#### 拷贝初始化
当使用直接初始化时，实际是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。  
当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。  
拷贝初始化不仅在我们用=定义变量时会发生。在以下情况也会发生：  
1  将一个对象作为实参传递给一个非引用类型的形参；
2  从一个返回类型为非引用的类型的函数返回一个对象；
3  用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。
#### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果（一个无名的临时变量）。  
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型（否则会陷入无限调用拷贝构造函数的情况）。

### 拷贝赋值运算符
与拷贝构造函数一样，如果类**未定义自己的拷贝赋值运算符**，**编译器会为它合成**一个**合成拷贝赋值运算符**。
#### 重载赋值运算符
重载运算符本质上是函数，其名字由**operator关键字**后接表示要定义的运算符的符号组成。
```
class Foo{
public:
    Foo& operator=(const Foo&);//赋值运算符
};
```
赋值运算符通常**应该返回一个指向其左侧运算对象的引用**。

### 析构函数
析构函数执行与构造函数相反的操作：析构函数释放对象使用的资源，并**销毁对象的非static数据成员**。  
析构函数是类的一个成员函数，名字由**波浪号接类名构成**。它**没有返回值，也不接受参数**：
```
class Foo{
public:
    ~Foo();//析构函数
};
```
由于析构函数不接受参数，因此它**不能被重载**。
#### 析构函数完成什么工作
如同构造函数有一个初始化部分和一个函数体，析构函数也有一个**函数体**和一个**析构部分**。   
在构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。  
在析构函数中，**首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。**  
在对象最后一次使用之后，析构函数的**函数体**可**执行类设计者希望执行的任何收尾工作**。通常，析构函数释放对象在生存期分配的所有资源。  
不存在类似构造函数中的初始化列表的东西来控制成员如何销毁，**析构部分是隐式的**。成员销毁时发生什么完全依赖于成员的类型。销毁类类型成员需要执行成员自己的析构函数。  
内置类型没有析构函数，因此**销毁内置类型成员什么也不需要做**。  
**隐式销毁一个内置指针类型的成员不会delete它指向的对象**。  
智能指针是类类型，所以具有析构函数。智能指针成员在析构阶段会被自动销毁。
#### 什么时候会调用析构函数
无论何时一个**对象被销毁，就会自动调用其析构函数**：  
&emsp;●变量在离开其作用域时会被销毁。   
&emsp;●当一个对象被销毁时，其成员被销毁。  
&emsp;●容器被销毁时，其元素被销毁。  
&emsp;●对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁。  
&emsp;●对于临时对象，当创建它的完整表达式结束时被销毁。  
当指向一个对象的**引用或指针**离开作用域时，析构函数不会执行。  
认识到**析构函数体**自身并**不直接销毁成员**是非常重要的。成员是在析构函数体**之后隐含的析构阶段中被销毁的**。

### 三/五法则
三个基本操作：拷贝构造函数、拷贝赋值运算符和析构函数；在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。
#### 需要析构函数的类也需要拷贝和赋值操作
如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。
#### 需要靠背操作的类也需要赋值操作，反之亦然
如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然——如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝运算符都不必然意味着也需要析构函数。

### 使用=default
我们可以通过拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。

### 阻止拷贝
大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。但对于某些类来说，这些操作没有合理的意义。
#### 定义删除的函数
在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何的方式使用它们。  
在函数的参数列表后面加上**=delete**来指出我们希望将它定义为删除的。
```
struct NoCopy{
    NoCopy() = default;
    NoCopy(const NoCopy&) = delete; //阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete; //阻止赋值
}
```
#### 析构函数不能是删除的成员
我们不能删除析构函数。如果析构函数被删除，就午饭销毁此类型的对象了。  
对于删除了析构函数的类型，虽然我们**不能定义这种类型的变量或成员**，但**可以动态分配这种类型的对象**。但是，**不能释放**这些对象。  
对于析构函数已删除的类型，**不能定义该类型的变量或释放指向该类型动态分配对象的指针**。

#### 合成的拷贝控制成员可能是删除的
对某些类来说，编译器将这些合成的成员定义为删除的函数：
&emsp;●如果类的某个成员的析构函数是删除的或不可访问的（如，是private的），则类的合成析构函数被定义为删除的。  
&emsp;●如果类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。  
&emsp;●如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。  
&emsp;●如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。  
本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

## 拷贝控制和资源管理
一个类类型对象的**拷贝语义**，一般来说有两种选择：可以定义拷贝操作，使类的行为看起来像一个**值**或者像一个**指针**。  
在标准库类中，标准库容器和string类的行为像一个值。shared_ptr类提供类似指针的行为。IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。
### 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。
#### 赋值运算符
当你编写赋值运算符时，有两点需要记住：  
&emsp;●如果**将一个对象赋予它自身，赋值运算符必须能正常工作**。  
&emsp;●大多数赋值运算符组合了析构函数和拷贝构造函数的工作。  
当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

### 行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它所指向的对象。我们的类仍然需要自己的析构函数来释放成员动态分配的内存（为了避免悬空指针，应实现引用计数或直接使用shared_ptr）。

## 交换操作
除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。  
**如果一个类定义了自己的swap，那么算法将使用自定义版本。否则，算法将使用标准库定义的swap。**  
与其使用中间量存值的方式来交换两个元素（这些内存分配是不必要的），我们**更希望swap交换指针**。  
### 编写自己的swap函数
```
class HasPtr{
    friend void swap(HasPtr&,HasPtr&);
    //....
};
inline
void swap(HasPtr &lhs,HasPtr &rhs){
    using std::swap;
    swap(lhs.ps,rhs.ps);
    swap(lhs.i,rhs.i);
}
```
由于swap的存在就是为了优化代码，我们将其声明为inline函数。  
与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。  
### swap函数应该调用swap，而不是std::swap
每个swap调用应该都是未加限定的（故使用using声明标准库swap，这样在函数内部，所有swap都无需限定）。如果存在类型特定的swap版本，swap调用会与之匹配。如果不存在类型特定的版本，则会使用std中的版本。
### 在赋值运算符中使用swap
定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换**的技术。
```
//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数
HasPtr& HasPtr::operator=(HasPtr rhs){
    swap(*this,rhs);//rhs现在指向本对象曾经使用过的内存
    return *this;//rhs被销毁。delete了rhs中的指针
}
```
在这个版本的赋值运算符中，**参数并不是一个引用**。  
使用拷贝和交换的赋值运算符自动就是**异常安全**的，且能正确处理自赋值。

## 对象移动
### 右值引用
**一般**而言，一个**左值表达式**表示的是一个**对象的身份**，而一个**右值表达式**表示的是**对象的值**。
```
int i = 42;
int &r = i; //正确，左值引用
int &&rr = i; //错误，不能将一个右值引用直接绑定到一个左值上
int &r2 = i * 42; //错误，i*42是一个右值
const int &r3 = i * 42; //正确，我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42; //正确
```
返回左值引用（所有普通&引用）的函数、赋值、下标、解引用和前置递增/递减运算符，都**是返回左值的表达式**。  
返回非引用类型的函数、算术、关系、位以及后置递增/递减运算符，都**生成右值**。
#### 左值持久，右值短暂
右值只能绑定到临时对象：  
&emsp;●所引用的对象将要被销毁。  
&emsp;●该对象没有其他用户。  
这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。

### move
虽然不能将一个右值引用直接绑定到一个左值上，但我们可以通过调用一个名为**move**的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件**utility**中。  
```
int &&rr3 = std::move(rr1); //ok
```
move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。  

### 移动构造函数和移动赋值运算符
这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。  
#### 移动构造函数
类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，但是**右值引用**。  
除了完成资源移动，移动构造函数还必须**保证移后源对象处于**这样一个状态——**销毁它是无害的**。  
```
StrVec::StrVec(StrVec &&s) noexcept: //移动操作不应抛出任何异常
    elements(s.elements),first_free(s.first_free),cap(s.cap){
    //保证销毁移后源对象是无害的
    s.elements=s.first_free=s.cap=nullptr;
    }
```
在接管内存之后，我们**应将源对象中的指针都置为nullptr**。最终，移后源对象会被销毁，意味着将在其上运行析构函数。**如果忘了改变源对象的elements那么就会释放我们移动的内存！**
#### 移动操作、标准库容器和异常
由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。  
**不抛出异常**的移动构造函数和移动赋值运算符必须标记为**noexcept**。  
我们需要一个移动操作不抛出异常，这是因为两个相互关联的事实：首先虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。  
#### 移动赋值运算符
```
StrVec &StrVec::operator=(StrVec &&rhs) noexcept{
    if(this != rhs){
        free();
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.element=rhs.first_free=rhs.cap=nullptr;
    }
    return *this;
}
```
在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。
#### 合成的移动操作
如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。  
只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。  
定义了一个移动构造函数或移动赋值运算符的类也必须定义自己的拷贝操作。否则，这些成员都默认地定义为删除的。
#### 移动迭代器
我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。  
原迭代器的所有其他操作在移动迭代器中都照常工作。  
值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时才能将移动迭代器传递给参数。  
#### 编写 String StrVec Message 移动操作后总结
获取右值引用对象的成员时，指针可以直接获取：  （指针是右值？）
```
StrVec::StrVec(StrVec &&s) noexcept: //移动操作不应抛出任何异常
    elements(s.elements),first_free(s.first_free),cap(s.cap){
    //保证销毁移后源对象是无害的
    s.elements=s.first_free=s.cap=nullptr;
    }
```
而如果获取成员为容器时需要使用std::move ：（左值？）
```
Message::Message(Message &&m) 
    :contents(std::move(m.contents)) {
    move_Folders(&m);
}
```

### 右值引用和成员函数
除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。  
```
StrVec vec;
string s="aaaa";
vec.push_back(s);//调用push_back(const string&)
vec.push_back("aaaa");//调用push_back(string&&)
```

#### 引用限定符 
引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。  
类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。  
若与const限定符同时出现，引用限定符必须跟在const限定符之后：
```
class Foo{
public:
    Foo someMen*() const &;
}
```
#### 重载和引用函数
就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。  
如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。